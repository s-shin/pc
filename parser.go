package pc

import (
	"fmt"
	"io"
	"regexp"
	"strconv"
	"strings"

	"github.com/pkg/errors"
)

//---

// ParseResult is the result generated by parsers.
type ParseResult struct {
	Value     interface{}
	TextRange TextRange
}

// ParseResultZero is zero value of ParseResult
var ParseResultZero = ParseResult{}

// TODO: use case
// func WrapParseResults(rs []ParseResult) ParseResult {
// 	if len(rs) == 0 {
// 		return ParseResult{}
// 	}
// 	return ParseResult{rs, TextRange{rs[0].TextRange.Start, rs[len(rs)-1].TextRange.End}}
// }

//---

// ParseError is common type of the error generated by parsers.
type ParseError struct {
	Reason    error
	TextRange TextRange
}

func (e ParseError) Error() string {
	return e.Reason.Error()
}

// Cause implements https://godoc.org/github.com/pkg/errors#Cause.
func (e ParseError) Cause() error {
	return e.Reason
}

// ParseError reasons.
const (
	ReasonNotEnough      = "not enough data"
	ReasonNotMatched     = "not matched"
	ReasonUnexpectedType = "unexpected type"
)

//---

// Parser interface
type Parser interface {
	Parse(r Reader) (ParseResult, error)
}

//---

// Constants passed to ParserInfo#Pattern.
const (
	PatternStyleRegexp = iota
	PatternStyleDiagnostics
)

// ParserInfo is optional interface of Parser.
type ParserInfo interface {
	// Name returns the parser name.
	Name() string
	// Pattern returns the pattern representation accepted by the parser.
	// The pattern should be like regular expression.
	Pattern(style int) string
}

// StringifyParser generates the string representation of the parser.
func StringifyParser(parser Parser, style int) string {
	if info, ok := parser.(ParserInfo); ok {
		switch style {
		case PatternStyleRegexp:
			return info.Pattern(style)
		case PatternStyleDiagnostics:
			return "<" + info.Name() + ":" + info.Pattern(style) + ">"
		}
	}
	return fmt.Sprintf("<%T>", parser)
}

//---

// TODO
type Walkable interface {
	Walk(cb func(parser Parser))
}

//---

// ParseTransaction is an useful helper for writing a parser..
type ParseTransaction struct {
	*Transaction
	reader Reader
	start  TextPosition
}

// NewParseTransaction creates an instance.
func NewParseTransaction(r Reader) *ParseTransaction {
	txn := &ParseTransaction{
		Transaction: NewTransaction(r),
		reader:      r,
	}
	txn.start = r.CurrentPosition()
	return txn
}

// Start returns the start position just after Begin.
func (t *ParseTransaction) Start() TextPosition {
	return t.start
}

// Range returns the range from the start position to the current position.
func (t *ParseTransaction) Range() TextRange {
	return TextRange{t.start, t.reader.CurrentPosition()}
}

// MakeError creates ParseError with the range of the transatction.
// MakeError also rollbacks the transaction.
func (t *ParseTransaction) MakeError(reason string) error {
	t.Rollback()
	return ParseError{errors.New(reason), t.Range()}
}

// MakeResult creates ParseResult with the range of the transatction.
// MakeResult also commits the transaction.
func (t *ParseTransaction) MakeResult(value interface{}) ParseResult {
	t.Commit()
	return ParseResult{value, t.Range()}
}

//------------------------------------------------------------------------------
// Core Parsers
//------------------------------------------------------------------------------

type annotateParser struct {
	parser  Parser
	name    string
	pattern func(style int) string
}

func (p *annotateParser) Parse(r Reader) (ParseResult, error) {
	return p.parser.Parse(r)
}

func (p *annotateParser) Name() string {
	return p.name
}

func (p *annotateParser) Pattern(style int) string {
	return p.pattern(style)
}

func (p *annotateParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

// Annotate annotates desc to parser.
func Annotate(parser Parser, name, pattern string) Parser {
	return &annotateParser{parser, name, func(style int) string { return pattern }}
}

// AnnotateStyleable annotates desc to parser.
func AnnotateStyleable(parser Parser, name string, pattern func(style int) string) Parser {
	return &annotateParser{parser, name, pattern}
}

//---

// MatchReaderFunc is the type of the function passed to MatchReader
// and is same as the interface of regexp.Regexp.FindReaderIndex.
// Also see https://golang.org/pkg/regexp/#Regexp.FindReaderIndex.
type MatchReaderFunc func(r io.RuneReader) (loc []int)

type matchReaderParser struct {
	matchFunc MatchReaderFunc
}

func (p *matchReaderParser) Parse(r Reader) (ParseResult, error) {
	txn := NewParseTransaction(r)
	defer txn.Guard()
	r.Begin()
	loc := p.matchFunc(r)
	r.Rollback()
	if loc == nil || loc[0] != 0 {
		return ParseResultZero, txn.MakeError(ReasonNotMatched)
	}
	runes := make([]rune, 0, loc[1])
	for i := 0; i < loc[1]; i++ {
		rune, _, err := r.ReadRune()
		if err != nil {
			return ParseResultZero, txn.MakeError("unexpected error")
		}
		runes = append(runes, rune)
	}
	return txn.MakeResult(string(runes)), nil
}

func (p *matchReaderParser) Name() string {
	return "Match"
}

func (p *matchReaderParser) Pattern(style int) string {
	return fmt.Sprintf("...%#v...", p.matchFunc)
}

func (p *matchReaderParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

// MatchReader is a parser generator and is available in general purpose.
func MatchReader(matchFunc MatchReaderFunc) Parser {
	return &matchReaderParser{matchFunc}
}

// MatchRune is the special wrapper of MatchReader for single rune.
func MatchRune(match func(r rune) bool) Parser {
	return MatchReader(func(r io.RuneReader) []int {
		rune, _, err := r.ReadRune()
		if err != nil || !match(rune) {
			return nil
		}
		return []int{0, 1}
	})
}

//---

type manyParser struct {
	repeated  Parser
	min, max  int
	terminate Parser
}

func (p *manyParser) Parse(r Reader) (ParseResult, error) {
	txn := NewParseTransaction(r)
	defer txn.Guard()
	results := make([]ParseResult, 0, p.min)
	for p.max <= 0 || len(results) <= p.max {
		pos := r.CurrentPosition()
		result, err := p.repeated.Parse(r)
		if err != nil || pos == r.CurrentPosition() {
			break
		}
		results = append(results, result)

		if p.terminate != nil {
			r.Begin()
			result, err := p.terminate.Parse(r)
			if err != nil {
				r.Rollback()
				continue
			}
			results = append(results, result)
			r.Commit()
			break
		}
	}
	if len(results) < p.min {
		return ParseResultZero, txn.MakeError(ReasonNotEnough)
	}
	return txn.MakeResult(results), nil
}

func (p *manyParser) Name() string {
	return "Many"
}

func (p *manyParser) Pattern(style int) string {
	repeated := StringifyParser(p.repeated, style)
	var repeat string
	if p.max > 0 {
		if p.max == 1 {
			repeat = "?"
		} else {
			repeat = fmt.Sprintf("{%d,%d}", p.min, p.max)
		}
	} else if p.min > 0 {
		repeat = "+"
	} else {
		repeat = "*"
	}
	if p.terminate != nil {
		terminate := StringifyParser(p.terminate, style)
		return fmt.Sprintf("(%s|(!?%s))%s%s", repeated, terminate, repeat, terminate)
	}
	return "(" + repeated + ")" + repeat
}

func (p *manyParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

// ManyMinMaxTerminate is ...
// The result value is slice of ParseResult.
func ManyMinMaxTerminate(repeated Parser, min, max int, terminate Parser) Parser {
	return &manyParser{repeated, min, max, terminate}
}

//---

type andParser struct {
	parsers []Parser
}

func (p *andParser) Parse(r Reader) (ParseResult, error) {
	txn := NewParseTransaction(r)
	defer txn.Guard()
	results := make([]ParseResult, 0, len(p.parsers))
	for _, parser := range p.parsers {
		result, err := parser.Parse(r)
		if err != nil {
			return ParseResultZero, txn.MakeError(ReasonNotMatched)
		}
		results = append(results, result)
	}
	return txn.MakeResult(results), nil
}

func (p *andParser) Name() string {
	return "And"
}

func (p *andParser) Pattern(style int) string {
	ss := make([]string, 0, len(p.parsers))
	for _, parser := range p.parsers {
		ss = append(ss, StringifyParser(parser, style))
	}
	return strings.Join(ss, "")
}

func (p *andParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

// And is ...
// The result value is slice of ParseResult.
func And(parsers ...Parser) Parser {
	return &andParser{parsers}
}

//---

type orParser struct {
	parsers []Parser
}

func (p *orParser) Parse(r Reader) (ParseResult, error) {
	for _, parser := range p.parsers {
		r.Begin()
		result, err := parser.Parse(r)
		if err != nil {
			r.Rollback()
			continue
		}
		r.Commit()
		return result, nil
	}
	pos := r.CurrentPosition()
	return ParseResultZero, ParseError{errors.New(ReasonNotMatched), TextRange{pos, pos}}
}

func (p *orParser) Name() string {
	return "Or"
}

func (p *orParser) Pattern(style int) string {
	ss := make([]string, 0, len(p.parsers))
	for _, parser := range p.parsers {
		ss = append(ss, StringifyParser(parser, style))
	}
	return "(" + strings.Join(ss, "|") + ")"
}

func (p *orParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

// Or tries to apply `parsers` in order.
// The result value is ParseResult or nil.
func Or(parsers ...Parser) Parser {
	return &orParser{parsers}
}

//---

type transformParser struct {
	parser    Parser
	transform func(value interface{}) (interface{}, error)
}

func (p *transformParser) Parse(r Reader) (ParseResult, error) {
	result, err := p.parser.Parse(r)
	if err != nil {
		return ParseResultZero, err
	}
	value, err := p.transform(result.Value)
	if err != nil {
		return ParseResultZero, ParseError{errors.Wrap(err, "failed to transform"), result.TextRange}
	}
	return ParseResult{value, result.TextRange}, nil
}

func (p *transformParser) Name() string {
	return "Transform"
}

func (p *transformParser) Pattern(style int) string {
	return StringifyParser(p.parser, style)
}

func (p *transformParser) String() string {
	return StringifyParser(p, PatternStyleRegexp)
}

func Transform(parser Parser, transform func(value interface{}) (interface{}, error)) Parser {
	return &transformParser{parser, transform}
}

func TransformAsResults(parser Parser, transform func(results []ParseResult) (interface{}, error)) Parser {
	return Transform(parser, func(value interface{}) (interface{}, error) {
		results, ok := value.([]ParseResult)
		if !ok {
			return nil, errors.New(ReasonUnexpectedType)
		}
		return transform(results)
	})
}

func Filter(parser Parser, includeTrue func(value interface{}) bool) Parser {
	return TransformAsResults(parser, func(results []ParseResult) (interface{}, error) {
		filtered := make([]ParseResult, 0, len(results))
		for _, result := range results {
			if includeTrue(result.Value) {
				filtered = append(filtered, result)
			}
		}
		return filtered, nil
	})
}

//---

type lazyParser struct {
	construct  func(me Parser) Parser
	parser     Parser
	stringifed bool
}

func (p *lazyParser) Parse(r Reader) (ParseResult, error) {
	if p.parser == nil {
		p.parser = p.construct(p)
	}
	return p.parser.Parse(r)
}

func (p *lazyParser) Name() string {
	return "Lazy"
}

func (p *lazyParser) Pattern(style int) string {
	if p.parser == nil {
		p.parser = p.construct(p)
	}
	if !p.stringifed {
		p.stringifed = true
		defer func() { p.stringifed = false }()
		return StringifyParser(p, PatternStyleRegexp)
	}
	return fmt.Sprintf("...%T...", p)
}

func (p *lazyParser) String() string {
	return StringifyParser(p.parser, PatternStyleRegexp)
}

// Lazy constructs Parser when it is used.
// It can realize recursive combination but cause infinite loop uncarefully.
func Lazy(construct func(me Parser) Parser) Parser {
	return &lazyParser{construct, nil, false}
}

//------------------------------------------------------------------------------
// Transformers
//------------------------------------------------------------------------------

func Tap(parser Parser, tap func(value interface{})) Parser {
	return Transform(parser, func(value interface{}) (interface{}, error) {
		tap(value)
		return value, nil
	})
}

func Flatten(parser Parser) Parser {
	return TransformAsResults(parser, func(results []ParseResult) (interface{}, error) {
		rs := make([]ParseResult, 0, len(results))
		for _, r := range results {
			if value, ok := r.Value.([]ParseResult); ok {
				rs = append(rs, value...)
			} else {
				rs = append(rs, r)
			}
		}
		return rs, nil
	})
}

// FilterNil removes results each of which has nil.
func FilterNil(parser Parser) Parser {
	return Filter(parser, func(value interface{}) bool {
		return value != nil
	})
}

func Many(parser Parser) Parser {
	return ManyMinMaxTerminate(parser, 0, 0, nil)
}

func Many1(parser Parser) Parser {
	return ManyMinMaxTerminate(parser, 1, 0, nil)
}

// Maybe accepts zero or one section that can be parsed with `parser`.
func Maybe(parser Parser) Parser {
	return TransformAsResults(
		ManyMinMaxTerminate(parser, 0, 1, nil),
		func(results []ParseResult) (interface{}, error) {
			if len(results) == 0 {
				return nil, nil
			}
			return results[0].Value, nil
		},
	)
}

func ConcatString(parser Parser) Parser {
	return TransformAsResults(FilterNil(parser), func(results []ParseResult) (interface{}, error) {
		strs := make([]string, 0, len(results))
		for _, result := range results {
			str, ok := result.Value.(string)
			if !ok {
				return nil, errors.New(ReasonUnexpectedType)
			}
			strs = append(strs, str)
		}
		return strings.Join(strs, ""), nil
	})
}

// Const transforms the result value by `parser` to `replaced`.
func Const(parser Parser, replaced interface{}) Parser {
	return Transform(parser, func(value interface{}) (interface{}, error) {
		return replaced, nil
	})
}

// TransformByParseString is the helper of transformer to parse string result.
func TransformByParseString(parser Parser, parseString func(s string) (interface{}, error)) Parser {
	return Transform(parser, func(value interface{}) (interface{}, error) {
		s, ok := value.(string)
		if !ok {
			return nil, errors.New(ReasonUnexpectedType)
		}
		v, err := parseString(s)
		if err != nil {
			return nil, errors.WithStack(err)
		}
		return v, nil
	})
}

// TransformToInt64 converts the string result value to int64.
func TransformToInt64(parser Parser) Parser {
	return TransformByParseString(parser, func(s string) (interface{}, error) {
		return strconv.ParseInt(s, 10, 64)
	})
}

// TransformToNumber converts the string result value to int64 or float64.
func TransformToNumber(parser Parser) Parser {
	return TransformByParseString(parser, func(s string) (interface{}, error) {
		if v, err := strconv.ParseInt(s, 10, 64); err == nil {
			return v, nil
		}
		if v, err := strconv.ParseFloat(s, 64); err == nil {
			return v, nil
		}
		return nil, errors.New("failed to convert to either int64 and float64")
	})
}

func Index(parser Parser, i int) Parser {
	return TransformAsResults(parser, func(results []ParseResult) (interface{}, error) {
		if i >= len(results) {
			return nil, errors.New(ReasonNotEnough)
		}
		return results[i].Value, nil
	})
}

//---

// Identity returns `parser` itself.
func Identity(parser Parser) Parser {
	return parser
}

// Composable is the function type that can be composed.
type Composable func(parser Parser) Parser

// Compose composes Composable functions.
// `Compose(A, B, C)(parser)` is equivalent to `A(B(C(parser)))`.
func Compose(transformers ...Composable) Composable {
	return func(parser Parser) Parser {
		var composed = parser
		for i := len(transformers) - 1; i >= 0; i-- {
			composed = transformers[i](composed)
		}
		return composed
	}
}

//------------------------------------------------------------------------------
// Derived Parsers and Combinators
//------------------------------------------------------------------------------

func runemap(rs []rune) map[rune]struct{} {
	m := make(map[rune]struct{})
	for _, r := range rs {
		m[r] = struct{}{}
	}
	return m
}

// Rune matches the single rune that is `r`.
func Rune(r rune) Parser {
	return AnnotateStyleable(
		MatchRune(func(rune rune) bool {
			return r == rune
		}),
		"Rune",
		func(style int) string {
			return regexp.QuoteMeta(string(r))
		},
	)
}

// RuneIn matches the single rune that is in `runes`.
func RuneIn(runes string) Parser {
	runemap := runemap([]rune(runes))
	return AnnotateStyleable(
		MatchRune(func(r rune) bool {
			_, ok := runemap[r]
			return ok
		}),
		"RuneIn",
		func(style int) string {
			// FIXME: escape character classes correctly
			return "[" + regexp.QuoteMeta(string(runes)) + "]"
		},
	)
}

// RuneNotIn matches the singe rune that is not in `runes`.
func RuneNotIn(runes string) Parser {
	runemap := runemap([]rune(runes))
	return AnnotateStyleable(
		MatchRune(func(r rune) bool {
			_, ok := runemap[r]
			return !ok
		}),
		"RuneNotIn",
		func(style int) string {
			// FIXME: escape character classes correctly
			return "[^" + regexp.QuoteMeta(string(runes)) + "]"
		},
	)
}

// RuneInRange matches the singe rune that is between `start` and `end`.
func RuneInRange(start, end rune) Parser {
	return AnnotateStyleable(
		MatchRune(func(r rune) bool {
			return start <= r && r <= end
		}),
		"RuneInRange",
		func(style int) string {
			return fmt.Sprintf("[%s-%s]", string(start), string(end))
		})
}

// RuneNotInRange matches the singe rune that is not between `start` and `end`.
func RuneNotInRange(start, end rune) Parser {
	return AnnotateStyleable(
		MatchRune(func(r rune) bool {
			return !(start <= r && r <= end)
		}),
		"RuneNotInRange",
		func(style int) string {
			return fmt.Sprintf("[^%s-%s]", string(start), string(end))
		},
	)
}

// AnyRune matches any single rune.
func AnyRune() Parser {
	return AnnotateStyleable(
		MatchRune(func(r rune) bool {
			return true
		}),
		"AnyRune",
		func(style int) string {
			return "."
		},
	)
}

// Regexp matcher.
func Regexp(re *regexp.Regexp) Parser {
	return AnnotateStyleable(
		MatchReader(re.FindReaderIndex),
		"Regexp",
		func(style int) string {
			return re.String()
		},
	)
}

// String matcher.
func String(s string) Parser {
	runes := []rune(s)
	parsers := make([]Parser, 0, len(runes))
	for _, rune := range runes {
		parsers = append(parsers, Rune(rune))
	}
	return Annotate(
		ConcatString(And(parsers...)),
		"String",
		regexp.QuoteMeta(s),
	)
}

// StringByAnd is the composition of And, Flatten, and ConcatString.
func StringByAnd(parsers ...Parser) Parser {
	return ConcatString(Flatten(And(parsers...)))
}

// StringByMany is the composition of Many and ConcatString.
func StringByMany(parser Parser) Parser {
	return ConcatString(Many(parser))
}

// StringByMany1 is the composition of Many1 and ConcatString.
func StringByMany1(parser Parser) Parser {
	return ConcatString(Many1(parser))
}

func Surround(markStart string, repeated Parser, markEnd, escape string) Parser {
	markStartParser := Const(String(markStart), nil)
	markEndParser := Const(String(markEnd), nil)
	return StringByAnd(
		markStartParser,
		ConcatString(
			ManyMinMaxTerminate(
				Or(
					Const(String(escape+string(escape[0])), string(escape[0])),
					Const(String(escape+string(markEnd[0])), string(markEnd[0])),
					repeated,
				),
				0,
				0,
				markEndParser,
			),
		),
	)
}

func Separated(repeated Parser, separator Parser) Parser {
	return Compose(FilterNil, Flatten)(
		And(
			repeated,
			Compose(Flatten, Many)(
				And(
					Const(separator, nil),
					repeated,
				),
			),
		),
	)
}
